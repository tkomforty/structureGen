<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structure Generator V3 - Icons & Views (Fix)</title>
    <script src="https://cdn.tailwindcss.com"></script> <style>
        /* Load Lucide Icons font */
        @font-face {
            font-family: 'LucideIcons';
            /* Updated CDN URL for lucide font */
            src: url(https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.ttf) format('truetype');
        }
        /* Style for elements using the icon font */
        .lucide {
            font-family: 'LucideIcons';
            font-size: 1.5rem; /* Adjust icon size as needed */
            line-height: 1; /* Ensure icon aligns correctly */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            display: inline-block; /* Prevents layout shifts */
            font-style: normal;
            font-weight: normal;
            speak: none;
            text-rendering: auto;
        }
        /* Define content for specific icons using their codepoints */
        .icon-reset::before { content: "\F045F"; } /* rotate-ccw */
        .icon-save::before { content: "\F0475"; } /* save */
        .icon-top-view::before { content: "\F005F"; } /* arrow-up-circle */
        .icon-iso-still::before { content: "\F0102"; } /* box */
        .icon-iso-rotate::before { content: "\F06F0"; } /* rotate-3d */

        /* Add a simple spin animation for the reset button */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
    </style>
    <style>
        /* Basic styles */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #1f2937; /* Tailwind gray-800 */
            color: #f3f4f6; /* Tailwind gray-100 */
        }
        /* Loading indicator style */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1rem;
            padding: 1rem 1.5rem;
            background: rgba(31, 41, 55, 0.9); /* Tailwind gray-800 with opacity */
            border-radius: 0.5rem; /* Tailwind rounded-lg */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* Tailwind shadow-md */
            border: 1px solid rgba(75, 85, 99, 0.5); /* Tailwind gray-600 */
            text-align: center;
            z-index: 20; /* Ensure loading is on top */
        }
        /* Controls container style */
        .controls {
            position: absolute;
            bottom: 1rem; /* Position at bottom */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            background: rgba(55, 65, 81, 0.85); /* Tailwind gray-700 with opacity */
            padding: 0.75rem;
            border-radius: 0.75rem; /* Tailwind rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Tailwind shadow-lg */
            border: 1px solid rgba(75, 85, 99, 0.5); /* Tailwind gray-600 */
            display: flex; /* Use flexbox for layout */
            gap: 0.75rem; /* Space between buttons */
            z-index: 10; /* Ensure controls are above canvas */
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
            justify-content: center; /* Center buttons when wrapped */
        }
        /* "Realistic" Button Style using Tailwind classes */
        .control-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.6rem; /* Adjust padding for icon buttons */
            background-image: linear-gradient(to bottom, #4b5563, #374151); /* Tailwind gray-600 to gray-700 gradient */
            color: white;
            border: 1px solid #6b7280; /* Tailwind gray-500 border */
            border-radius: 0.5rem; /* Tailwind rounded-lg */
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.2s ease; /* Smooth transitions */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 1px rgba(255, 255, 255, 0.1); /* Subtle shadow + inner highlight */
            min-width: 44px; /* Ensure minimum tap target size for mobile */
            min-height: 44px;
        }
        .control-btn:hover {
            background-image: linear-gradient(to bottom, #525d6b, #414b59); /* Lighter gradient on hover */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), inset 0 1px 1px rgba(255, 255, 255, 0.1);
            transform: translateY(-1px); /* Slight lift effect */
        }
        .control-btn:active {
            background-image: linear-gradient(to top, #4b5563, #374151); /* Invert gradient on click */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2), inset 0 1px 2px rgba(0, 0, 0, 0.1); /* Inner shadow effect */
            transform: translateY(0px); /* Reset lift */
        }
        .control-btn:disabled {
            opacity: 0.5; /* Dim disabled button */
            cursor: not-allowed;
            transform: translateY(0px);
            background-image: linear-gradient(to bottom, #6b7280, #4b5563); /* Grayed out gradient */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); /* Minimal shadow */
        }
        /* Ensure canvas fills the screen */
        canvas {
             display: block; /* Remove extra space below canvas */
             width: 100%;
             height: 100%;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="loading">Loading 3D scene...<br><span id="loading-details" class="text-xs text-gray-400">Initializing...</span></div>

    <div class="controls" style="display:none;">
        <button id="resetBtn" class="control-btn" title="Reset Building">
            <span class="lucide icon-reset"></span>
        </button>
        <button id="saveBtn" class="control-btn" title="Save Image">
            <span class="lucide icon-save"></span>
        </button>
        <button id="topBtn" class="control-btn" title="Top View">
            <span class="lucide icon-top-view"></span>
        </button>
        <button id="isoBtn" class="control-btn" title="Isometric View (Still)">
            <span id="isoIcon" class="lucide icon-iso-still"></span> </button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>

        // --- Event Listener for DOM Load ---
        window.addEventListener('load', function() {
            // Use a small delay to ensure fonts/styles might be ready before init
            setTimeout(init, 100);
        });

        // --- Core Three.js Components ---
        let scene, renderer;
        let perspectiveCamera, orthographicCamera, activeCamera; // Cameras for different views
        let directionalLight; // Main light source

        // --- Animation & State Variables ---
        let buildingParts = []; // Array to hold all generated meshes (floors, features, etc.)
        let towerPositions = []; // Stores data about each generated tower cluster
        let currentPartIndex = 0; // Index for revealing parts during animation
        let animationSpeed = 0.25; // Controls how quickly new parts are *revealed* (0 to 1)
        let growthIntervals = []; // Stores interval IDs for smooth scaling animations
        let currentViewMode = 'iso-still'; // Tracks the current camera view: 'iso-still', 'iso-rotate', 'top'
        const Y_EPSILON = 0.01; // Tiny vertical gap to prevent Z-fighting/clipping between stacked elements

        // --- Building Generation Parameters ---
        const GRID_SIZE = 18; // Logical grid size for tower placement area
        const CELL_SIZE = 6.5; // Size of a logical grid cell, influences tower base size
        const MAX_HEIGHT = 17; // Maximum number of floors for a tower
        const FLOOR_HEIGHT = 2.6; // Height of a single floor unit
        const BASE_PLATFORM_AREA_SIZE = (GRID_SIZE + 3) * CELL_SIZE; // Total area where grass/buildings appear
        const GROUND_PLANE_SIZE = 350; // Size of the large plane underneath everything

        // --- Scene Atmosphere ---
        const fogColor = 0x4a5a6a; // Dark blue-grey fog
        const fogNear = 30; // Distance where fog starts
        const fogFar = 220; // Distance where fog becomes opaque

        // --- Rain Particle System (Always On) ---
        let rainParticles, rainGeometry, rainMaterial;
        const rainCount = 15000; // Number of raindrops

        // --- Grass Particle System ---
        let grassParticles, grassGeometry, grassMaterial;
        let grassOriginalPositions; // Stores base positions for wind animation
        const GRASS_COUNT = 80000; // Number of grass blades (particles)
        const GRASS_DOT_COLOR = 0x8FBC8F; // Muted green color (DarkSeaGreen)
        const GRASS_DOT_SIZE = 0.3; // Size of each grass particle
        const GRASS_MAX_HEIGHT = 0.5; // Maximum random height offset for grass blades
        const WIND_STRENGTH = 0.15; // How much grass moves horizontally
        const WIND_FREQUENCY = 0.05; // How fast the wind pattern changes

        // --- L-System Tree Generation ---
        let treeMeshes = []; // Array to hold generated tree groups for cleanup
        const TREE_COUNT = 50; // Number of trees to generate
        // Palette of materials for tree branches
        const treeMaterials = [
            new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.9, metalness: 0.05 }), // ForestGreen
            new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 0.9, metalness: 0.05 }), // DarkOliveGreen
            new THREE.MeshStandardMaterial({ color: 0x8FBC8F, roughness: 0.9, metalness: 0.05 }), // DarkSeaGreen
            new THREE.MeshStandardMaterial({ color: 0x90EE90, roughness: 0.9, metalness: 0.05 }), // LightGreen
            new THREE.MeshStandardMaterial({ color: 0xFF8C00, roughness: 0.9, metalness: 0.05 }), // DarkOrange (Autumn variation)
            new THREE.MeshStandardMaterial({ color: 0xFF4500, roughness: 0.9, metalness: 0.05 }), // OrangeRed (Autumn variation)
            new THREE.MeshStandardMaterial({ color: 0xDAA520, roughness: 0.9, metalness: 0.05 }), // Goldenrod (Autumn variation)
        ];
        const BRANCH_RADIUS = 0.1; // Base radius for tree branches

        // --- Shared Materials ---
        // Default palette (will be replaced by API fetch if successful)
        let concreteMaterials = [
            new THREE.MeshStandardMaterial({ color: 0x8c8c8c, roughness: 0.85, metalness: 0.1 }), // Medium grey
            new THREE.MeshStandardMaterial({ color: 0xa0a0a0, roughness: 0.8, metalness: 0.1 }),  // Lighter grey
            new THREE.MeshStandardMaterial({ color: 0x7a7a7a, roughness: 0.9, metalness: 0.05 }), // Darker grey
            new THREE.MeshStandardMaterial({ color: 0x99908a, roughness: 0.88, metalness: 0.1 }), // Brownish grey
            new THREE.MeshStandardMaterial({ color: 0x8f8f80, roughness: 0.9, metalness: 0.08 }), // Greenish grey
        ];
        // Material for distinct features like roof elements, cantilevers, etc.
        const featureMaterial = new THREE.MeshStandardMaterial({ color: 0x606060, roughness: 0.9, metalness: 0.15 });
        // Materials for windows (dark and light variations)
        const windowMaterialDark = new THREE.MeshStandardMaterial({ color: 0x334455, roughness: 0.3, metalness: 0.8, transparent: true, opacity: 0.65, side: THREE.DoubleSide });
        const windowMaterialLight = new THREE.MeshStandardMaterial({ color: 0x778899, roughness: 0.4, metalness: 0.7, transparent: true, opacity: 0.7, side: THREE.DoubleSide });
        // Material for window frames
        const windowFrameMaterial = new THREE.MeshStandardMaterial({ color: 0x404040, roughness: 0.7, metalness: 0.3 });

        // --- Colors ---
        const UNDERGROUND_COLOR = '#333333'; // Color for the large ground plane

        // --- UI Element References ---
        let resetBtn, saveBtn, topBtn, isoBtn, isoIcon; // To be assigned in init()

        /**
         * Updates the secondary text in the loading indicator.
         * @param {string} message - The message to display.
         */
        function updateLoadingDetails(message) {
            const detailsSpan = document.getElementById('loading-details');
            if (detailsSpan) {
                detailsSpan.textContent = message;
            }
        }

        /**
         * Fetches an analogic-complement color palette from TheColorAPI
         * and updates the concreteMaterials array. Uses defaults on failure.
         * @returns {Promise<void>}
         */
        async function fetchAnalogicComplementPalette() {
            updateLoadingDetails('Fetching color palette...');
            console.log("Fetching analogic-complement palette...");
            // Generate a random hex color for the API query
            const randomColorHex = Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            const apiUrl = `https://www.thecolorapi.com/scheme?hex=${randomColorHex}&mode=analogic-complement&count=5`; // Request 5 colors

            try {
                const response = await fetch(apiUrl);
                // Handle API errors or rate limits gracefully
                if (!response.ok) {
                    console.warn(`Color API request failed: ${response.status}. Using previous/default palette.`);
                    updateLoadingDetails('Color API failed. Using defaults.');
                    // Ensure default materials exist if fetch fails and array is empty
                    if (!concreteMaterials || concreteMaterials.length === 0) {
                        concreteMaterials = [ /* Default palette definition */
                            new THREE.MeshStandardMaterial({ color: 0x8c8c8c, roughness: 0.85, metalness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: 0xa0a0a0, roughness: 0.8, metalness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: 0x7a7a7a, roughness: 0.9, metalness: 0.05 }),
                            new THREE.MeshStandardMaterial({ color: 0x99908a, roughness: 0.88, metalness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: 0x8f8f80, roughness: 0.9, metalness: 0.08 }),
                        ];
                    }
                    return; // Exit, keeping the existing palette
                }
                const data = await response.json();

                // Process successful response
                if (data.colors && data.colors.length >= 5) {
                    // Dispose old materials before creating new ones to free GPU memory
                    concreteMaterials.forEach(mat => mat.dispose());
                    // Create new materials from the fetched colors
                    concreteMaterials = data.colors.map(colorInfo => {
                        return new THREE.MeshStandardMaterial({
                            color: colorInfo.hex.value,
                            roughness: 0.8 + Math.random() * 0.15, // Add slight random variation
                            metalness: 0.05 + Math.random() * 0.1  // Add slight random variation
                        });
                    });
                    console.log("New color palette applied:", concreteMaterials.map(m => m.color.getHexString()));
                    updateLoadingDetails('Color palette loaded.');
                } else {
                    throw new Error("Invalid data received from Color API");
                }
            } catch (error) {
                console.error("Error fetching or applying color palette:", error);
                updateLoadingDetails('Failed to load color palette. Using defaults.');
                // Fallback: Ensure default materials exist if any error occurred
                if (!concreteMaterials || concreteMaterials.length === 0) {
                     concreteMaterials = [ /* Default palette definition */
                         new THREE.MeshStandardMaterial({ color: 0x8c8c8c, roughness: 0.85, metalness: 0.1 }),
                         new THREE.MeshStandardMaterial({ color: 0xa0a0a0, roughness: 0.8, metalness: 0.1 }),
                         new THREE.MeshStandardMaterial({ color: 0x7a7a7a, roughness: 0.9, metalness: 0.05 }),
                         new THREE.MeshStandardMaterial({ color: 0x99908a, roughness: 0.88, metalness: 0.1 }),
                         new THREE.MeshStandardMaterial({ color: 0x8f8f80, roughness: 0.9, metalness: 0.08 }),
                    ];
                }
            }
        }

        /**
         * Randomizes the position of the directional light for different shadow angles.
         */
        function randomizeLightDirection() {
            if (!directionalLight) return; // Safety check
            // Keep Y positive and reasonably high for a sun-like effect
            const lightY = 60 + Math.random() * 40; // 60 to 100
            // Randomize X and Z for direction
            const lightX = (Math.random() - 0.5) * 150; // -75 to 75
            const lightZ = (Math.random() - 0.5) * 150; // -75 to 75
            directionalLight.position.set(lightX, lightY, lightZ);
            // Optional: Make light always point towards the origin (0,0,0)
            // directionalLight.target.position.set(0, 0, 0);
            // scene.add(directionalLight.target); // Target needs adding if changed from default
            console.log("Randomized light direction to:", directionalLight.position);
        }

        /**
         * Returns a random concrete material from the current palette.
         * @returns {THREE.MeshStandardMaterial}
         */
        function getRandomConcreteMaterial() {
            // Ensure the array is not empty (e.g., if API failed badly)
            if (!concreteMaterials || concreteMaterials.length === 0) {
                console.warn("Concrete materials array is empty, returning default grey.");
                return new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.85, metalness: 0.1 });
            }
            return concreteMaterials[Math.floor(Math.random() * concreteMaterials.length)];
        }

        /**
         * Creates and adds a mesh part to the scene and the buildingParts array for animation.
         * Sets mesh to invisible initially.
         * @param {THREE.BufferGeometry} geometry - The geometry.
         * @param {THREE.Material} material - The material.
         * @param {THREE.Vector3} position - The target world position.
         * @param {THREE.Vector3} scale - The target scale.
         * @param {THREE.Euler} [rotation=null] - The target rotation.
         * @param {Object} [additionalData={}] - Extra data (e.g., { name: 'floor_1' }).
         * @returns {THREE.Mesh} The created mesh.
         */
        function addBuildingMeshPart(geometry, material, position, scale, rotation = null, additionalData = {}) {
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position); // Set final position
            mesh.scale.copy(scale);       // Set final scale (will be animated from small)
            if (rotation) mesh.rotation.copy(rotation); // Set final rotation
            mesh.castShadow = true;       // Allow casting shadows
            mesh.receiveShadow = true;    // Allow receiving shadows
            mesh.visible = false;         // Start invisible, will be revealed by animation loop
            mesh.name = additionalData.name || ''; // Assign name if provided
            scene.add(mesh);

            // Store data needed for animation and potential reset
            buildingParts.push({
                mesh: mesh,
                position: position.clone(), // Store target position
                scale: scale.clone(),       // Store target scale
                rotation: rotation ? rotation.clone() : null, // Store target rotation
                ...additionalData
            });
            return mesh; // Return the mesh in case it's needed immediately
        }

        /**
         * Generates the entire building structure, including towers and bridges.
         * Clears previous structure and populates the global `towerPositions` array.
         */
        function generateBuilding() {
            updateLoadingDetails('Generating structure...');
            console.log("--- generateBuilding START ---");
            // --- Cleanup previous building ---
            console.log("Cleaning up old building parts...");
            buildingParts.forEach(part => {
                if (part.mesh) { // Check if mesh exists
                    scene.remove(part.mesh);
                    // Dispose geometry to free GPU memory
                    if (part.mesh.geometry) part.mesh.geometry.dispose();
                    // Materials are shared and managed globally, no need to dispose here
                }
            });
            buildingParts = []; // Reset building parts array
            towerPositions = []; // Reset tower positions array
            growthIntervals.forEach(clearInterval); // Clear any ongoing growth animations
            growthIntervals = [];
            currentPartIndex = 0; // Reset animation index

            // --- Generate Towers ---
            const numTowers = 4 + Math.floor(Math.random() * 4); // 4-7 main tower clusters
            console.log(`Generating ${numTowers} towers...`);

            for (let i = 0; i < numTowers; i++) {
                let x, z, width, depth, height;
                let attempts = 0;
                let positionValid = false;
                const maxAttempts = 30; // Limit attempts to find a spot

                // Try to find a non-overlapping position for the new tower
                while (!positionValid && attempts < maxAttempts) {
                    // Random position within the allowed base area, avoiding edges
                    const maxPos = (BASE_PLATFORM_AREA_SIZE / 2) - CELL_SIZE * 1.5;
                    x = (Math.random() * 2 - 1) * maxPos;
                    z = (Math.random() * 2 - 1) * maxPos;

                    // Taller height average
                    height = 7 + Math.floor(Math.random() * (MAX_HEIGHT - 6)); // Min height 7 floors

                    // Slightly narrower base dimensions favored
                    let gridWidthCells = (Math.random() < 0.6 ? 1.2 : (Math.random() < 0.85 ? 1.8 : 2.2));
                    let gridDepthCells = (Math.random() < 0.6 ? 1.2 : (Math.random() < 0.85 ? 1.8 : 2.2));
                    width = gridWidthCells * CELL_SIZE;
                    depth = gridDepthCells * CELL_SIZE;

                    // Check if the tower fits within the base platform bounds
                    positionValid = true;
                    if (Math.abs(x) + width > BASE_PLATFORM_AREA_SIZE / 2 ||
                        Math.abs(z) + depth > BASE_PLATFORM_AREA_SIZE / 2) {
                        positionValid = false;
                        attempts++;
                        continue; // Try again if out of bounds
                    }

                    // Overlap check using simple radius approximation
                    const currentCenter = { x: x + width/2, z: z + depth/2 }; // Center of this tower attempt
                    const currentRadius = Math.sqrt(width*width + depth*depth) / 2; // Approx radius

                    for (const pos of towerPositions) { // Check against existing towers
                        const dx = currentCenter.x - pos.center.x;
                        const dz = currentCenter.z - pos.center.z;
                        const distance = Math.sqrt(dx*dx + dz*dz);
                        // Check if radii overlap with a buffer zone
                        if (distance < currentRadius + pos.radius + CELL_SIZE * 0.8) {
                            positionValid = false;
                            break; // Overlaps, stop checking this position
                        }
                    }
                    attempts++;
                } // End while trying to find position

                // If no valid position found after max attempts, skip this tower
                if (!positionValid) {
                    console.log(`Skipping tower ${i+1}, could not find valid position after ${maxAttempts} attempts.`);
                    continue;
                }

                // Store tower data (using world coordinates x, z for the corner)
                const towerData = {
                    x: x, z: z, // World position of corner
                    initialWidth: width, initialDepth: depth,
                    height: height,
                };
                // Add to global towerPositions array for overlap checks and bridge logic
                towerPositions.push({
                    center: {x: towerData.x + width/2, z: towerData.z + depth/2}, // Center for overlap check
                    radius: Math.sqrt(width*width + depth*depth)/2, // Radius for overlap check
                    height: height, // Store height for bridge logic
                    x: towerData.x, z: towerData.z, // Store corner
                    width: width, depth: depth // Store dimensions
                });

                // Generate the actual tower floors and features
                addTower(towerData);

                // --- Add Bridges (Connects current tower to a random previous one) ---
                if (towerPositions.length > 1 && Math.random() < 0.55) { // Increased probability
                    // Select a random previous tower to connect to
                    const prevTowerIndex = Math.floor(Math.random() * (towerPositions.length - 1));
                    const prevTowerPosData = towerPositions[prevTowerIndex];
                    const currentTowerPosData = towerPositions[towerPositions.length - 1]; // The one just added

                    // Check height compatibility for bridge placement
                    const maxHeightForBridge = Math.min(currentTowerPosData.height, prevTowerPosData.height);
                    if (maxHeightForBridge > 4) { // Ensure towers are reasonably tall
                        // Place bridge somewhere between floor 2 and (maxHeight - 2)
                        const bridgeYLevel = 2 + Math.floor(Math.random() * (maxHeightForBridge - 4));
                        // Add tiny gap to bridge Y position based on level
                        const bridgeY = FLOOR_HEIGHT / 2 + bridgeYLevel * FLOOR_HEIGHT + Y_EPSILON * bridgeYLevel;

                        // Use center positions for simpler bridge calculation
                        addBridge(prevTowerPosData.center.x, prevTowerPosData.center.z, currentTowerPosData.center.x, currentTowerPosData.center.z, bridgeY);
                    }
                } // End bridge generation
            } // End tower generation loop

            // Sort parts by Y position for a bottom-up animation reveal effect
            buildingParts.sort((a, b) => a.position.y - b.position.y);
            console.log(`Generated ${buildingParts.length} building parts.`);
            console.log(`Generated ${towerPositions.length} towers.`);
            updateLoadingDetails('Structure generated.');
            console.log("--- generateBuilding END ---");
        }

        /**
         * Adds a single tower structure floor by floor, with variations and features.
         * Applies Y_EPSILON to prevent clipping between floors.
         * @param {object} towerData - Contains initial position, dimensions, and height.
         */
        function addTower(towerData) {
            let currentWidth = towerData.initialWidth;
            let currentDepth = towerData.initialDepth;
            let currentRotationY = 0; // Base rotation for the whole tower

            // Chance for the entire tower to have a slight base rotation
            if (Math.random() < 0.15) {
                currentRotationY = (Math.random() - 0.5) * Math.PI / 9; // Max ~20 degrees
            }
            const baseRotation = new THREE.Euler(0, currentRotationY, 0);

            // Add floors one by one
            for (let floor = 0; floor < towerData.height; floor++) {
                // Calculate Y position: Center Y of the floor + small vertical gap (Y_EPSILON) based on floor index
                const y = FLOOR_HEIGHT / 2 + floor * FLOOR_HEIGHT + floor * Y_EPSILON;
                let floorRotation = baseRotation.clone(); // Start with base rotation

                // --- Floor Shape/Size/Rotation Variation (applied after first floor) ---
                if (floor > 1 && Math.random() < 0.45) { // Chance to taper
                    const widthFactor = 0.7 + Math.random() * 0.6;
                    const depthFactor = 0.7 + Math.random() * 0.6;
                    currentWidth = Math.max(CELL_SIZE * 0.6, currentWidth * widthFactor); // Ensure minimum size
                    currentDepth = Math.max(CELL_SIZE * 0.6, currentDepth * depthFactor); // Ensure minimum size
                }
                if (floor > 1 && Math.random() < 0.12) { // Chance to twist slightly
                    floorRotation.y += (Math.random() - 0.5) * Math.PI / 14;
                }

                // --- Floor Geometry & Material ---
                const geometry = new THREE.BoxGeometry(1, 1, 1); // Unit cube, scaled later
                const scale = new THREE.Vector3(currentWidth, FLOOR_HEIGHT, currentDepth);
                const material = getRandomConcreteMaterial(); // Use the function to get a random material
                // Calculate position based on tower corner and current dimensions
                const position = new THREE.Vector3(towerData.x + currentWidth/2, y, towerData.z + currentDepth/2);

                // Add the main floor block
                addBuildingMeshPart(geometry, material, position, scale, floorRotation, {name: `floor_${floor}`});

                // --- Add Windows (Higher chance on lower floors) ---
                const windowChance = (floor < 2) ? 0.75 : 0.5;
                if (Math.random() < windowChance) {
                    const sides = ['front', 'back', 'left', 'right'];
                    const numWindowSides = 1 + Math.floor(Math.random() * 1.2); // 1 or 2 sides with windows
                    const windowSides = sides.sort(() => 0.5 - Math.random()).slice(0, numWindowSides);
                    for (const side of windowSides) {
                        addWindows(position.x, y, position.z, currentWidth, currentDepth, floor, side, floorRotation);
                    }
                }

                // --- Add Balconies ---
                if (floor > 0 && floor < towerData.height - 1 && Math.random() < 0.12) { // Avoid ground/top floor
                    addBalcony(position.x, y, position.z, currentWidth, currentDepth, floorRotation);
                }

                // --- Add Adjacent Blocks (Smaller blocks attached to the side) ---
                 if (floor > 1 && floor < towerData.height - 2 && Math.random() < 0.18) { // Avoid lower/upper floors
                     addAdjacentBlock(position.x, y, position.z, currentWidth, currentDepth, floorRotation);
                 }
            } // End floor loop

            // --- Features added after all floors are defined (using final dimensions/rotation) ---
            const finalWidth = currentWidth;
            const finalDepth = currentDepth;
            const finalRotation = baseRotation; // Use the consistent base rotation for features attached to the main mass
            // Calculate center position based on the *initial* corner (towerData.x/z) and *final* dimensions
            const finalCenterPosition = new THREE.Vector3(towerData.x + finalWidth/2, 0, towerData.z + finalDepth/2); // XZ center at Y=0

            // --- Add Roof Feature ---
            if (Math.random() < 0.75) { // High chance of a roof feature
                // Calculate Y position of the surface of the topmost floor
                const topFloorY = FLOOR_HEIGHT / 2 + (towerData.height - 1) * FLOOR_HEIGHT + (towerData.height - 1) * Y_EPSILON;
                const roofSurfaceY = topFloorY + FLOOR_HEIGHT / 2 + Y_EPSILON; // Add epsilon gap above top floor
                addRoofFeature(finalCenterPosition.x, roofSurfaceY, finalCenterPosition.z, finalWidth, finalDepth, finalRotation);
            }

            // --- Add Brutalist Feature (e.g., cantilever, pilotis) ---
            if (towerData.height > 3 && Math.random() < 0.75) { // Only on reasonably tall towers
                // Choose a floor for the feature to originate from
                const featureFloorIndex = 1 + Math.floor(Math.random() * Math.max(1, towerData.height - 3)); // Avoid ground/top
                // Calculate the Y center of that floor, including epsilon gaps
                const featureFloorY = FLOOR_HEIGHT / 2 + featureFloorIndex * FLOOR_HEIGHT + featureFloorIndex * Y_EPSILON;
                addBrutalistFeature(finalCenterPosition.x, featureFloorY, finalCenterPosition.z, finalWidth, finalDepth, finalRotation, towerData);
            }
        }

        /**
         * Adds windows to a specific face of a floor block.
         * Includes Y_EPSILON offset to prevent clipping with floor face.
         */
        function addWindows(centerX, centerY, centerZ, width, depth, floor, side, floorRotation) {
            const windowStyleRand = Math.random();
            let windowStyle;
            if (floor < 2 && Math.random() < 0.5) { windowStyle = 'strip'; }
            else if (windowStyleRand < 0.5) { windowStyle = 'strip'; }
            else if (windowStyleRand < 0.85) { windowStyle = 'pattern'; }
            else { windowStyle = 'vertical_slits'; }

            const windowMaterial = Math.random() < 0.5 ? windowMaterialDark : windowMaterialLight;
            const recess = 0.25 + Math.random() * 0.2; // How far window is set back
            const frameThickness = 0.08;
            const addFrame = Math.random() < 0.4;
            const windowDepth = 0.1; // Thickness of the window pane geometry

            let winHeight, numWin = 1, spacing = 0, actualWindowWidth;
            let sideAxisLength = 0;
            let localNormal = new THREE.Vector3();
            let localTangent = new THREE.Vector3();
            let faceCenterOffset = new THREE.Vector3();

            // Define face properties based on side
            switch(side) {
                case 'front': sideAxisLength = width; localNormal.set(0, 0, 1); localTangent.set(1, 0, 0); faceCenterOffset.set(0, 0, depth / 2); break;
                case 'back': sideAxisLength = width; localNormal.set(0, 0, -1); localTangent.set(-1, 0, 0); faceCenterOffset.set(0, 0, -depth / 2); break;
                case 'left': sideAxisLength = depth; localNormal.set(-1, 0, 0); localTangent.set(0, 0, 1); faceCenterOffset.set(-width / 2, 0, 0); break;
                case 'right': sideAxisLength = depth; localNormal.set(1, 0, 0); localTangent.set(0, 0, -1); faceCenterOffset.set(width / 2, 0, 0); break;
            }

            // Define window dimensions based on style
             switch(windowStyle) {
                 case 'strip': winHeight = FLOOR_HEIGHT * (0.4 + Math.random() * 0.4); actualWindowWidth = sideAxisLength * 0.9; numWin = 1; break;
                 case 'pattern': numWin = Math.floor(Math.random() * 3) + 2; winHeight = FLOOR_HEIGHT * (0.5 + Math.random() * 0.3); spacing = sideAxisLength / numWin; actualWindowWidth = spacing * 0.65; break;
                 case 'vertical_slits': numWin = Math.floor(Math.random() * 4) + 3; winHeight = FLOOR_HEIGHT * (0.7 + Math.random() * 0.2); spacing = sideAxisLength / numWin; actualWindowWidth = spacing * 0.15; break;
             }

             // Adjust size for lower floors
             if (floor < 2) {
                 winHeight *= 1.1;
                 if (windowStyle === 'strip') { actualWindowWidth = sideAxisLength * 0.95; }
             }
             winHeight = Math.min(winHeight, FLOOR_HEIGHT * 0.95); // Ensure height doesn't exceed floor height

            // Create and place windows
            const geom = new THREE.BoxGeometry(actualWindowWidth, winHeight, windowDepth);
            const scale = new THREE.Vector3(1, 1, 1);

            for (let i = 0; i < numWin; i++) {
                let tangentOffset = 0;
                if (numWin > 1) { tangentOffset = (i - (numWin - 1) / 2) * spacing; }

                // Calculate local position relative to floor center
                let localPosition = faceCenterOffset.clone();
                // Move outwards by recess + epsilon to avoid Z-fighting
                localPosition.addScaledVector(localNormal, recess + Y_EPSILON);
                localPosition.addScaledVector(localTangent, tangentOffset);

                // Apply floor rotation to the local offset
                let rotatedOffset = localPosition.clone().applyEuler(floorRotation);

                // Calculate final world position
                let winPosition = new THREE.Vector3(centerX, centerY, centerZ).add(rotatedOffset);

                // Calculate final window rotation
                let winRotation = floorRotation.clone();
                let alignQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), localNormal);
                winRotation.setFromQuaternion(new THREE.Quaternion().setFromEuler(winRotation).multiply(alignQuaternion));

                // Add the window pane
                addBuildingMeshPart(geom, windowMaterial, winPosition, scale, winRotation);

                // Add Frame (Optional)
                if (addFrame && windowStyle !== 'strip') {
                    const frameGeom = new THREE.BoxGeometry(actualWindowWidth + frameThickness * 2, winHeight + frameThickness * 2, frameThickness);
                    let rotatedNormal = localNormal.clone().applyEuler(floorRotation);
                    let framePositionOffset = rotatedNormal.clone().multiplyScalar(-windowDepth/2 - frameThickness/2);
                    let framePosition = winPosition.clone().add(framePositionOffset);
                    let frameRotation = winRotation.clone();
                    addBuildingMeshPart(frameGeom, windowFrameMaterial, framePosition, scale, frameRotation);
                }
            }
        }

        /**
         * Adds a balcony to a specific side of a floor block.
         * Includes Y_EPSILON offsets to prevent clipping.
         */
        function addBalcony(centerX, centerY, centerZ, width, depth, floorRotation) {
            const balconyDepth = CELL_SIZE * (0.4 + Math.random() * 0.4);
            const balconyWidthRatio = 0.5 + Math.random() * 0.4;
            const balconyHeight = FLOOR_HEIGHT * 0.1; // Thickness of the balcony floor slab
            const railingHeight = FLOOR_HEIGHT * 0.35;
            const railingThickness = 0.08;

            const sides = ['front', 'back', 'left', 'right'];
            const side = sides[Math.floor(Math.random() * sides.length)];

            const material = getRandomConcreteMaterial();
            let currentBalconyWidth;
            let localNormal = new THREE.Vector3();
            let faceCenterOffset = new THREE.Vector3();
            let sideAxisLength; // Length of the side the balcony attaches to

            // Define properties based on side
            switch (side) {
                case 'front': localNormal.set(0, 0, 1); faceCenterOffset.set(0, 0, depth / 2); sideAxisLength = width; currentBalconyWidth = width * balconyWidthRatio; break;
                case 'back': localNormal.set(0, 0, -1); faceCenterOffset.set(0, 0, -depth / 2); sideAxisLength = width; currentBalconyWidth = width * balconyWidthRatio; break;
                case 'left': localNormal.set(-1, 0, 0); faceCenterOffset.set(-width / 2, 0, 0); sideAxisLength = depth; currentBalconyWidth = depth * balconyWidthRatio; break; // Width is along Z here
                case 'right': localNormal.set(1, 0, 0); faceCenterOffset.set(width / 2, 0, 0); sideAxisLength = depth; currentBalconyWidth = depth * balconyWidthRatio; break; // Width is along Z here
            }

            // Balcony Floor Slab
            const floorGeom = new THREE.BoxGeometry(currentBalconyWidth, balconyHeight, balconyDepth);
            // Calculate Y position: Align top of balcony slab slightly below the floor's surface Y
            const floorSurfaceY = centerY - FLOOR_HEIGHT / 2 - Y_EPSILON;
            const balconyFloorCenterY = floorSurfaceY - balconyHeight / 2;

            // Calculate position: Start at floor center, move to face center, move out by half balcony depth + epsilon
            let localPosition = faceCenterOffset.clone().addScaledVector(localNormal, balconyDepth / 2 + Y_EPSILON);
            localPosition.y = balconyFloorCenterY - centerY; // Y relative to floor center

            let rotatedOffset = localPosition.clone().applyEuler(floorRotation);
            let finalPosition = new THREE.Vector3(centerX, centerY, centerZ).add(rotatedOffset);

            // Calculate rotation: Align balcony's Z axis (depth) with the localNormal
            let finalRotation = floorRotation.clone();
            let alignQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), localNormal);
            finalRotation.setFromQuaternion(new THREE.Quaternion().setFromEuler(finalRotation).multiply(alignQuaternion));

            addBuildingMeshPart(floorGeom, material, finalPosition, new THREE.Vector3(1,1,1), finalRotation);

            // Railing
            const railingGeom = new THREE.BoxGeometry(currentBalconyWidth, railingHeight, railingThickness);
            // Position railing on top of the balcony floor, at the outer edge
            let railingLocalOffset = new THREE.Vector3(0, balconyHeight / 2 + railingHeight / 2, balconyDepth / 2 - railingThickness / 2);
            let rotatedRailingOffset = railingLocalOffset.clone().applyEuler(finalRotation);
            let railingPosition = finalPosition.clone().add(rotatedRailingOffset);
            addBuildingMeshPart(railingGeom, material, railingPosition, new THREE.Vector3(1,1,1), finalRotation);
        }

        /**
         * Adds a smaller block attached to the side of a main floor block.
         * Includes Y_EPSILON offset to prevent clipping.
         */
        function addAdjacentBlock(centerX, centerY, centerZ, mainWidth, mainDepth, mainRotation) {
            const sizeRatio = 0.3 + Math.random() * 0.4;
            const adjHeight = FLOOR_HEIGHT * (1 + Math.floor(Math.random() * 3));
            const adjWidth = mainWidth * sizeRatio;
            const adjDepth = mainDepth * sizeRatio;

            const geometry = new THREE.BoxGeometry(adjWidth, adjHeight, adjDepth);
            const material = getRandomConcreteMaterial();
            const scale = new THREE.Vector3(1, 1, 1);

            // Determine attachment point
            const sides = [
                { normal: new THREE.Vector3(1,0,0), mainDim: mainWidth, adjDim: adjWidth },
                { normal: new THREE.Vector3(-1,0,0), mainDim: mainWidth, adjDim: adjWidth },
                { normal: new THREE.Vector3(0,0,1), mainDim: mainDepth, adjDim: adjDepth },
                { normal: new THREE.Vector3(0,0,-1), mainDim: mainDepth, adjDim: adjDepth }
            ];
            const attachSide = sides[Math.floor(Math.random() * sides.length)];
            let localAttachNormal = attachSide.normal;

            // Calculate local offset: Move from main center to edge, out by half adjacent size + epsilon
            let localOffset = localAttachNormal.clone().multiplyScalar(attachSide.mainDim / 2 + attachSide.adjDim / 2 * 0.9 + Y_EPSILON);
            // Align bottom of adjacent block with bottom of main block floor
            localOffset.y = (centerY - FLOOR_HEIGHT/2 + adjHeight/2) - centerY;

            // Apply main rotation to the offset
            let rotatedOffset = localOffset.clone().applyEuler(mainRotation);
            let finalPosition = new THREE.Vector3(centerX, centerY, centerZ).add(rotatedOffset);

            // Adjacent block rotation (slight variation)
            const adjRotation = mainRotation.clone();
            adjRotation.y += (Math.random() - 0.5) * Math.PI / 12;

            addBuildingMeshPart(geometry, material, finalPosition, scale, adjRotation);
        }

        /**
         * Adds a feature (mechanical box, antenna, etc.) to the roof surface.
         * Positions features relative to the provided roofSurfaceY. Includes Y_EPSILON offsets.
         */
        function addRoofFeature(centerX, roofSurfaceY, centerZ, width, depth, rotation) {
             const featureRand = Math.random();
             let featureType;
             if (featureRand < 0.3) featureType = 'mechanical_box';
             else if (featureRand < 0.55) featureType = 'antenna_array';
             else if (featureRand < 0.75) featureType = 'slanted_roof';
             else featureType = 'helipad';

            const featureHeight = FLOOR_HEIGHT * (0.6 + Math.random() * 1.2);
            const baseSize = Math.min(width, depth) * (0.4 + Math.random() * 0.3);
            // Calculate center Y of the feature, starting from roofSurfaceY
            const featureCenterY = roofSurfaceY + featureHeight / 2;
            const featureRotation = rotation.clone();
            const material = featureMaterial;

            // Calculate XZ position offset relative to tower center
            let localOffsetX = (Math.random() - 0.5) * width * 0.3;
            let localOffsetZ = (Math.random() - 0.5) * depth * 0.3;

            switch(featureType) {
                case 'mechanical_box': {
                    const boxWidth = baseSize;
                    const boxDepth = baseSize * (0.7 + Math.random() * 0.6);
                    const geometry = new THREE.BoxGeometry(boxWidth, featureHeight, boxDepth);
                    const scale = new THREE.Vector3(1, 1, 1);
                    let rotatedOffsetXZ = new THREE.Vector3(localOffsetX, 0, localOffsetZ).applyEuler(rotation);
                    let position = new THREE.Vector3(centerX, featureCenterY, centerZ).add(rotatedOffsetXZ);
                    addBuildingMeshPart(geometry, material, position, scale, featureRotation);
                    break;
                }
                case 'antenna_array': {
                    const numAntennas = 2 + Math.floor(Math.random() * 4);
                    const antennaHeight = featureHeight * 1.5;
                    const poleRadius = baseSize * 0.05;
                    const poleCenterY = roofSurfaceY + antennaHeight / 2; // Absolute Y
                    const poleMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.4, metalness: 0.6 });
                    const geometry = new THREE.CylinderGeometry(poleRadius, poleRadius * 0.5, antennaHeight, 6);
                    const scale = new THREE.Vector3(1, 1, 1);

                    for (let i = 0; i < numAntennas; i++) {
                        const antOffsetX = (Math.random() - 0.5) * baseSize * 1.2;
                        const antOffsetZ = (Math.random() - 0.5) * baseSize * 1.2;
                        let rotatedOffsetAntXZ = new THREE.Vector3(antOffsetX, 0, antOffsetZ).applyEuler(rotation);
                        const antPos = new THREE.Vector3(centerX, poleCenterY, centerZ).add(rotatedOffsetAntXZ);
                        addBuildingMeshPart(geometry.clone(), poleMat, antPos, scale, featureRotation);
                    }
                    break;
                }
                 case 'slanted_roof': {
                     const slantWidth = width * 0.9;
                     const slantDepth = depth * 0.9;
                     const slantThickness = FLOOR_HEIGHT * 0.15;
                     const geometry = new THREE.BoxGeometry(slantWidth, slantThickness, slantDepth);
                     const scale = new THREE.Vector3(1, 1, 1);
                     const slantCenterY = roofSurfaceY + slantThickness * 0.4; // Position slightly above surface
                     let position = new THREE.Vector3(centerX, slantCenterY, centerZ);
                     const slantAxis = Math.random() < 0.5 ? 'x' : 'z';
                     const slantAngle = (Math.random() < 0.5 ? 1 : -1) * (Math.PI / 8 + Math.random() * Math.PI / 8);
                     if (slantAxis === 'x') featureRotation.x += slantAngle;
                     else featureRotation.z += slantAngle;
                     addBuildingMeshPart(geometry, material, position, scale, featureRotation);
                     break;
                 }
                 case 'helipad': {
                     const helipadRadius = baseSize * 0.7;
                     const helipadHeight = FLOOR_HEIGHT * 0.1;
                     const geometry = new THREE.CylinderGeometry(helipadRadius, helipadRadius, helipadHeight, 32);
                     const scale = new THREE.Vector3(1, 1, 1);
                     const helipadCenterY = roofSurfaceY + helipadHeight / 2; // Absolute Y
                     let position = new THREE.Vector3(centerX, helipadCenterY, centerZ);
                     const helipadMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
                     addBuildingMeshPart(geometry, helipadMat, position, scale, featureRotation);

                     // Add 'H' marking slightly above the pad
                     const hMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.9 });
                     const hBarWidth = helipadRadius * 0.1;
                     const hBarLength = helipadRadius * 0.5;
                     const hCrossLength = helipadRadius * 0.4;
                     const hThickness = helipadHeight * 0.1;
                     const hYOffsetFromPad = helipadHeight / 2 + hThickness / 2 + Y_EPSILON; // Y offset relative to helipad center

                     const hGeomVert = new THREE.BoxGeometry(hBarWidth, hThickness, hBarLength);
                     const hGeomCross = new THREE.BoxGeometry(hCrossLength, hThickness, hBarWidth);
                     const hXOffset = hCrossLength / 2 - hBarWidth / 2;

                     // Position relative to helipad center, then apply rotation
                     let hPos1Local = new THREE.Vector3(-hXOffset, hYOffsetFromPad, 0);
                     let hPos1World = position.clone().add(hPos1Local.applyEuler(featureRotation));
                     addBuildingMeshPart(hGeomVert.clone(), hMat, hPos1World, scale, featureRotation);

                     let hPos2Local = new THREE.Vector3(hXOffset, hYOffsetFromPad, 0);
                     let hPos2World = position.clone().add(hPos2Local.applyEuler(featureRotation));
                     addBuildingMeshPart(hGeomVert.clone(), hMat, hPos2World, scale, featureRotation);

                     let hPosCrossLocal = new THREE.Vector3(0, hYOffsetFromPad, 0);
                     let hPosCrossWorld = position.clone().add(hPosCrossLocal.applyEuler(featureRotation));
                     addBuildingMeshPart(hGeomCross.clone(), hMat, hPosCrossWorld, scale, featureRotation);
                     break;
                 }
            }
        }

        /**
         * Adds a prominent Brutalist feature (cantilever, pilotis, fins, stair core) to a floor.
         * Positions features relative to the provided featureFloorY. Includes Y_EPSILON offsets.
         */
        function addBrutalistFeature(centerX, featureFloorY, centerZ, width, depth, rotation, towerData) {
            const featureRand = Math.random();
            let featureType;
            if (featureRand < 0.55) featureType = 'cantilever';
            else if (featureRand < 0.80) featureType = 'pilotis';
            else if (featureRand < 0.90) featureType = 'fins';
            else featureType = 'stair_core';

            const material = featureMaterial;
            const towerBaseY = 0;
            const towerTopY = towerBaseY + towerData.height * FLOOR_HEIGHT + (towerData.height -1) * Y_EPSILON;
            const towerCenterY = (towerBaseY + towerTopY) / 2;

            switch(featureType) {
                case 'cantilever': {
                    const cantHeight = FLOOR_HEIGHT * (0.9 + Math.random() * 0.6);
                    const cantLength = CELL_SIZE * (1.0 + Math.random() * 1.5);
                    const cantWidth = Math.min(width, depth) * (0.5 + Math.random() * 0.4);
                    const directions = [
                        { normal: new THREE.Vector3(1, 0, 0), mainDim: width, axis: 'x' },
                        { normal: new THREE.Vector3(-1, 0, 0), mainDim: width, axis: 'x' },
                        { normal: new THREE.Vector3(0, 0, 1), mainDim: depth, axis: 'z' },
                        { normal: new THREE.Vector3(0, 0, -1), mainDim: depth, axis: 'z' }
                    ];
                    const dirInfo = directions[Math.floor(Math.random() * directions.length)];
                    const localNormal = dirInfo.normal;

                    let cantActualWidth, cantActualDepth;
                    if (dirInfo.axis === 'x') { cantActualWidth = cantLength; cantActualDepth = cantWidth; }
                    else { cantActualWidth = cantWidth; cantActualDepth = cantLength; }

                    const geometry = new THREE.BoxGeometry(cantActualWidth, cantHeight, cantActualDepth);
                    const scale = new THREE.Vector3(1, 1, 1);

                    // Position relative to tower center
                    let localOffset = localNormal.clone().multiplyScalar(dirInfo.mainDim / 2 + cantLength / 2 + Y_EPSILON);
                    // Align bottom of cantilever with bottom of the feature floor
                    localOffset.y = (featureFloorY - FLOOR_HEIGHT/2 + cantHeight/2) - towerCenterY;

                    let rotatedOffset = localOffset.clone().applyEuler(rotation);
                    let position = new THREE.Vector3(centerX, towerCenterY, centerZ).add(rotatedOffset);

                    // Rotation
                    let cantRotation = rotation.clone();
                    let alignAxis = (dirInfo.axis === 'x') ? new THREE.Vector3(1,0,0) : new THREE.Vector3(0,0,1);
                    let alignQuat = new THREE.Quaternion().setFromUnitVectors(alignAxis, localNormal);
                    cantRotation.setFromQuaternion(new THREE.Quaternion().setFromEuler(cantRotation).multiply(alignQuat));

                    addBuildingMeshPart(geometry, material, position, scale, cantRotation);
                    break;
                }
                case 'pilotis': {
                    const pilotisSize = Math.min(width, depth) * (0.4 + Math.random() * 0.4);
                    const featureFloorBottomY = featureFloorY - FLOOR_HEIGHT / 2 - Y_EPSILON; // Bottom of slab
                    const pilotisHeight = featureFloorBottomY; // Height from ground
                    if (pilotisHeight <= FLOOR_HEIGHT * 0.5) break;
                    const pilotisCenterY = pilotisHeight / 2; // Absolute Y center

                    const cornerOffsetX = width / 2 * (Math.random() < 0.5 ? 1 : -1) * 0.8;
                    const cornerOffsetZ = depth / 2 * (Math.random() < 0.5 ? 1 : -1) * 0.8;

                    const pilotisGeom = Math.random() < 0.5
                        ? new THREE.BoxGeometry(pilotisSize, pilotisHeight, pilotisSize)
                        : new THREE.CylinderGeometry(pilotisSize/2, pilotisSize/2, pilotisHeight, 10);
                    const pilotisScale = new THREE.Vector3(1, 1, 1);

                    // Calculate absolute position
                    let localPilotisPosXZ = new THREE.Vector3(cornerOffsetX, 0, cornerOffsetZ);
                    let rotatedPilotisOffsetXZ = localPilotisPosXZ.clone().applyEuler(rotation);
                    let pilotisPos = new THREE.Vector3(centerX, pilotisCenterY, centerZ).add(rotatedPilotisOffsetXZ);

                    addBuildingMeshPart(pilotisGeom, material, pilotisPos, pilotisScale, rotation);
                    break;
                }
                 case 'fins': {
                     const finThickness = 0.2;
                     const finDepth = CELL_SIZE * (0.4 + Math.random() * 0.5);
                     const finHeight = FLOOR_HEIGHT * (2.5 + Math.random() * 3.5);
                     const numFins = Math.floor(Math.random() * 3) + 2;
                     const finSides = ['front', 'back', 'left', 'right'];
                     const finSide = finSides[Math.floor(Math.random() * finSides.length)];
                     let finNormal = new THREE.Vector3();
                     let finTangent = new THREE.Vector3();
                     let sideAxisLength, mainDimForOffset;

                     switch (finSide) {
                         case 'front': finNormal.set(0, 0, 1); finTangent.set(1, 0, 0); sideAxisLength = width; mainDimForOffset = depth; break;
                         case 'back': finNormal.set(0, 0, -1); finTangent.set(-1, 0, 0); sideAxisLength = width; mainDimForOffset = depth; break;
                         case 'left': finNormal.set(-1, 0, 0); finTangent.set(0, 0, 1); sideAxisLength = depth; mainDimForOffset = width; break;
                         case 'right': finNormal.set(1, 0, 0); finTangent.set(0, 0, -1); sideAxisLength = depth; mainDimForOffset = width; break;
                     }

                     // Absolute Y center of fin, aligned with feature floor bottom
                     const finCenterY = featureFloorY - FLOOR_HEIGHT / 2 + finHeight / 2;
                     const spacing = sideAxisLength / (numFins + 1);

                     let finGeomWidth, finGeomHeight, finGeomDepth;
                     finGeomHeight = finHeight;
                     if (finSide === 'front' || finSide === 'back') { finGeomWidth = finThickness; finGeomDepth = finDepth; }
                     else { finGeomWidth = finDepth; finGeomDepth = finThickness; }
                     const finGeom = new THREE.BoxGeometry(finGeomWidth, finGeomHeight, finGeomDepth);
                     const finScale = new THREE.Vector3(1, 1, 1);

                     for (let i = 0; i < numFins; i++) {
                         const tangentOffset = (i + 1 - (numFins + 1) / 2) * spacing;
                         const normalOffset = mainDimForOffset / 2 + finDepth / 2 + Y_EPSILON; // Outwards + epsilon

                         // Combine offsets locally in XZ plane
                         let localFinPosXZ = finTangent.clone().multiplyScalar(tangentOffset);
                         localFinPosXZ.addScaledVector(finNormal, normalOffset);

                         // Rotate local XZ offset and add to tower center XZ, use absolute Y
                         let rotatedFinOffsetXZ = localFinPosXZ.clone().applyEuler(rotation);
                         let finPosition = new THREE.Vector3(centerX, finCenterY, centerZ).add(rotatedFinOffsetXZ);

                         // Rotation
                         let finRotation = rotation.clone();
                         let alignAxis = (finSide === 'front' || finSide === 'back') ? new THREE.Vector3(0,0,1) : new THREE.Vector3(1,0,0);
                         let alignQuatFin = new THREE.Quaternion().setFromUnitVectors(alignAxis, finNormal);
                         finRotation.setFromQuaternion(new THREE.Quaternion().setFromEuler(finRotation).multiply(alignQuatFin));

                         addBuildingMeshPart(finGeom.clone(), material, finPosition, finScale, finRotation);
                     }
                     break;
                 }
                 case 'stair_core': {
                     const coreSize = CELL_SIZE * (1.0 + Math.random() * 0.6);
                     const coreHeight = FLOOR_HEIGHT * (towerData.height * (0.7 + Math.random() * 0.5));
                     const coreCenterY = coreHeight / 2; // Absolute Y center
                     const coreGeom = new THREE.BoxGeometry(coreSize, coreHeight, coreSize);
                     const coreScale = new THREE.Vector3(1, 1, 1);

                     const attachSides = [
                         { normal: new THREE.Vector3(1,0,0), mainDim: width }, { normal: new THREE.Vector3(-1,0,0), mainDim: width },
                         { normal: new THREE.Vector3(0,0,1), mainDim: depth }, { normal: new THREE.Vector3(0,0,-1), mainDim: depth }
                     ];
                     const attachInfo = attachSides[Math.floor(Math.random() * attachSides.length)];
                     const localAttachNormal = attachInfo.normal;

                     // Position relative to tower center
                     let localCoreOffset = localAttachNormal.clone().multiplyScalar(attachInfo.mainDim / 2 + coreSize / 2 * 0.9 + Y_EPSILON);
                     localCoreOffset.y = coreCenterY - towerCenterY; // Y relative to tower center Y

                     let rotatedCoreOffset = localCoreOffset.clone().applyEuler(rotation);
                     let corePos = new THREE.Vector3(centerX, towerCenterY, centerZ).add(rotatedCoreOffset);

                     addBuildingMeshPart(coreGeom, material, corePos, coreScale, rotation);

                     // Add minimal vertical slits
                     if (Math.random() < 0.5) {
                         const numSlits = Math.floor(coreHeight / FLOOR_HEIGHT);
                         const slitHeight = FLOOR_HEIGHT * 0.3;
                         const slitWidth = coreSize * 0.08;
                         const slitDepth = 0.15;
                         const slitGeom = new THREE.BoxGeometry(slitWidth, slitHeight, slitDepth);
                         const slitMat = windowMaterialDark;
                         const slitScale = new THREE.Vector3(1, 1, 1);

                         let slitSideNormal;
                         if (Math.abs(localAttachNormal.x) > 0.5) { slitSideNormal = Math.random() < 0.5 ? new THREE.Vector3(0,0,1) : new THREE.Vector3(0,0,-1); }
                         else { slitSideNormal = Math.random() < 0.5 ? new THREE.Vector3(1,0,0) : new THREE.Vector3(-1,0,0); }

                         for (let j=0; j < numSlits; j++) {
                             const slitY_inCore = (j + 0.5) * FLOOR_HEIGHT;
                             if (slitY_inCore > coreHeight - slitHeight/2) continue;

                             // Position relative to core center + epsilon outwards
                             let localSlitPos = slitSideNormal.clone().multiplyScalar(coreSize / 2 + slitDepth / 2 + Y_EPSILON);
                             localSlitPos.y = slitY_inCore - coreCenterY; // Y relative to core center

                             // Rotate slit offset by core rotation and add to core position
                             let rotatedSlitOffset = localSlitPos.clone().applyEuler(rotation);
                             let slitPos = corePos.clone().add(rotatedSlitOffset);

                             // Rotation
                             let slitRotation = rotation.clone();
                             let alignQuatSlit = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), slitSideNormal);
                             slitRotation.setFromQuaternion(new THREE.Quaternion().setFromEuler(slitRotation).multiply(alignQuatSlit));

                             addBuildingMeshPart(slitGeom.clone(), slitMat, slitPos, slitScale, slitRotation);
                         }
                     }
                     break;
                 }
            } // End switch
        }


        /**
         * Adds a bridge connecting two points at a specific height. Includes Y_EPSILON offsets.
         */
        function addBridge(x1, z1, x2, z2, y) {
            const midX = (x1 + x2) / 2;
            const midZ = (z1 + z2) / 2;
            const dx = x2 - x1;
            const dz = z2 - z1;
            const length = Math.sqrt(dx * dx + dz * dz);
            if (length < CELL_SIZE * 2.0) return;

            const angle = Math.atan2(dx, dz);
            const bridgeRotation = new THREE.Euler(0, angle, 0);

            const bridgeWidth = CELL_SIZE * (0.4 + Math.random() * 1.0);
            const bridgeHeight = FLOOR_HEIGHT * (0.5 + Math.random() * 0.8);

            const geometry = new THREE.BoxGeometry(bridgeWidth, bridgeHeight, length);
            const material = concreteMaterials[2 % concreteMaterials.length];
            const position = new THREE.Vector3(midX, y, midZ); // Y already includes epsilon
            const scale = new THREE.Vector3(1, 1, 1);

            addBuildingMeshPart(geometry, material, position, scale, bridgeRotation);

            // Optional side detail
            if (Math.random() < 0.6) {
                const detailHeight = bridgeHeight * 0.4;
                const detailThickness = 0.15;
                const detailLength = length * 0.95;
                const detailMat = concreteMaterials[1 % concreteMaterials.length];
                const detailGeom = new THREE.BoxGeometry(detailThickness, detailHeight, detailLength);
                const detailScale = new THREE.Vector3(1, 1, 1);

                for (let i = -1; i <= 1; i += 2) {
                    // Offset relative to bridge center + epsilon outwards
                    const localOffsetX = (bridgeWidth / 2 + detailThickness / 2 + Y_EPSILON) * i;
                    let localOffset = new THREE.Vector3(localOffsetX, 0, 0);
                    let rotatedOffset = localOffset.clone().applyEuler(bridgeRotation);
                    let detailPos = position.clone().add(rotatedOffset);
                    addBuildingMeshPart(detailGeom.clone(), detailMat, detailPos, detailScale, bridgeRotation);
                }
            }
        }

        // --- Rain Functions ---
        /** Initializes the rain particle system. */
        function initRain() {
             rainGeometry = new THREE.BufferGeometry();
             const positions = []; const velocities = [];
             const rainAreaSize = GROUND_PLANE_SIZE;
             const rainHeight = MAX_HEIGHT * FLOOR_HEIGHT * 2.2;
             for (let i = 0; i < rainCount; i++) {
                 positions.push( (Math.random() - 0.5) * rainAreaSize, Math.random() * rainHeight, (Math.random() - 0.5) * rainAreaSize );
                 velocities.push(0, -(0.9 + Math.random() * 0.6), 0);
             }
             rainGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
             rainGeometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
             rainMaterial = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.3, transparent: true, opacity: 0.6, sizeAttenuation: true });
             rainParticles = new THREE.Points(rainGeometry, rainMaterial);
             scene.add(rainParticles);
             console.log("Rain system initialized.");
        }
        /** Animates the rain particles falling. */
        function animateRain() {
             if (!rainParticles) return;
             const positions = rainParticles.geometry.attributes.position.array;
             const velocities = rainParticles.geometry.attributes.velocity.array;
             const rainAreaSize = GROUND_PLANE_SIZE;
             const rainHeight = MAX_HEIGHT * FLOOR_HEIGHT * 2.2;
             const groundLevel = -0.5;
             for (let i = 0; i < rainCount; i++) {
                 const index = i * 3;
                 positions[index + 1] += velocities[index + 1];
                 if (positions[index + 1] < groundLevel) {
                     positions[index] = (Math.random() - 0.5) * rainAreaSize;
                     positions[index + 1] = rainHeight + Math.random() * 10;
                     positions[index + 2] = (Math.random() - 0.5) * rainAreaSize;
                 }
             }
             rainParticles.geometry.attributes.position.needsUpdate = true;
        }

        // --- Grass Functions ---
        /** Initializes the grass particle system. */
        function initGrass() {
             updateLoadingDetails('Planting grass...');
             console.log("--- initGrass START ---");
             grassGeometry = new THREE.BufferGeometry();
             const positions = [];
             grassOriginalPositions = [];
             const grassAreaSize = BASE_PLATFORM_AREA_SIZE;
             for (let i = 0; i < GRASS_COUNT; i++) {
                 const x = (Math.random() - 0.5) * grassAreaSize;
                 const y = Math.random() * GRASS_MAX_HEIGHT;
                 const z = (Math.random() - 0.5) * grassAreaSize;
                 positions.push(x, y, z);
                 grassOriginalPositions.push(x, y, z);
             }
             grassGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
             grassMaterial = new THREE.PointsMaterial({ color: GRASS_DOT_COLOR, size: GRASS_DOT_SIZE, sizeAttenuation: true, transparent: true, opacity: 0.8 });
             grassParticles = new THREE.Points(grassGeometry, grassMaterial);
             grassParticles.name = "GrassParticles";
             scene.add(grassParticles);
             console.log(`Grass system initialized with ${GRASS_COUNT} particles.`);
             console.log("--- initGrass END ---");
             updateLoadingDetails('Grass planted.');
        }
        /** Animates the grass particles to simulate wind. */
        function animateGrass() {
             if (!grassParticles || !grassOriginalPositions) return;
             const positions = grassParticles.geometry.attributes.position.array;
             const time = Date.now() * 0.0005;
             for (let i = 0; i < GRASS_COUNT; i++) {
                 const index = i * 3;
                 const originalX = grassOriginalPositions[index];
                 const originalY = grassOriginalPositions[index + 1];
                 const originalZ = grassOriginalPositions[index + 2];
                 const windX = Math.sin(time + originalX * WIND_FREQUENCY + originalZ * WIND_FREQUENCY * 0.5) * WIND_STRENGTH;
                 positions[index] = originalX + windX;
                 positions[index + 1] = originalY;
             }
             grassParticles.geometry.attributes.position.needsUpdate = true;
        }

        // --- L-System Tree Functions ---
        /** Generates an L-system string. */
        function generateLSystemString(axiom, rules, iterations) {
             let currentString = axiom;
             for (let i = 0; i < iterations; i++) {
                 let nextString = '';
                 for (const char of currentString) {
                     nextString += rules[char] || char;
                 }
                 currentString = nextString;
             }
             return currentString;
        }
        /** Interprets L-system string to generate branch segments. */
        function interpretLSystemString(systemString, angle, stepLength) {
             const segments = [];
             const stack = [];
             let currentPos = new THREE.Vector3(0, 0, 0);
             let currentDir = new THREE.Vector3(0, 1, 0);
             const rotationMatrixZ = new THREE.Matrix4();
             for (const char of systemString) {
                 switch (char) {
                     case 'F':
                         const nextPos = currentPos.clone().addScaledVector(currentDir, stepLength);
                         segments.push({ start: currentPos.clone(), end: nextPos.clone() });
                         currentPos = nextPos;
                         break;
                     case '+': rotationMatrixZ.makeRotationZ(angle); currentDir.applyMatrix4(rotationMatrixZ); break;
                     case '-': rotationMatrixZ.makeRotationZ(-angle); currentDir.applyMatrix4(rotationMatrixZ); break;
                     case '[': stack.push({ pos: currentPos.clone(), dir: currentDir.clone() }); break;
                     case ']':
                         const poppedState = stack.pop();
                         if (poppedState) { currentPos = poppedState.pos; currentDir = poppedState.dir; }
                         break;
                 }
             }
             return segments;
        }
        /** Creates a Tree Mesh (Group) from branch segments. */
        function createTreeMesh(branchSegments) {
             const treeGroup = new THREE.Group();
             const material = treeMaterials[Math.floor(Math.random() * treeMaterials.length)];
             const direction = new THREE.Vector3();
             const midpoint = new THREE.Vector3();
             const orientation = new THREE.Quaternion();
             const up = new THREE.Vector3(0, 1, 0);
             branchSegments.forEach(segment => {
                 const length = segment.start.distanceTo(segment.end);
                 if (length < 0.01) return;
                 midpoint.lerpVectors(segment.start, segment.end, 0.5);
                 direction.subVectors(segment.end, segment.start).normalize();
                 const geometry = new THREE.CylinderGeometry(BRANCH_RADIUS, BRANCH_RADIUS * 0.8, length, 5);
                 const branchMesh = new THREE.Mesh(geometry, material);
                 branchMesh.castShadow = true;
                 branchMesh.position.copy(midpoint);
                 orientation.setFromUnitVectors(up, direction);
                 branchMesh.quaternion.copy(orientation);
                 treeGroup.add(branchMesh);
             });
             return treeGroup;
        }
        /** Generates and adds trees to the scene. */
        function addTrees(count) {
             updateLoadingDetails(`Generating ${count} trees...`);
             console.log(`--- addTrees START (${count}) ---`);
             const lSystemAxiom = 'F';
             const lSystemRules = { 'F': 'F[+F]F[-F]F' };
             const lSystemAngle = THREE.MathUtils.degToRad(25);
             const baseStepLength = 0.8;
             const placeAttempts = 10;
             for (let i = 0; i < count; i++) {
                 const iterations = 2 + Math.floor(Math.random() * 2);
                 const stepLength = baseStepLength * (0.8 + Math.random() * 0.4);
                 const lSystemString = generateLSystemString(lSystemAxiom, lSystemRules, iterations);
                 const branchSegments = interpretLSystemString(lSystemString, lSystemAngle, stepLength);
                 const tree = createTreeMesh(branchSegments);
                 let treeX, treeZ, validPosition = false;
                 for (let attempt = 0; attempt < placeAttempts; attempt++) {
                     treeX = (Math.random() - 0.5) * BASE_PLATFORM_AREA_SIZE;
                     treeZ = (Math.random() - 0.5) * BASE_PLATFORM_AREA_SIZE;
                     let overlaps = false;
                     for (const tower of towerPositions) {
                         if (treeX > tower.x - BRANCH_RADIUS && treeX < tower.x + tower.width + BRANCH_RADIUS &&
                             treeZ > tower.z - BRANCH_RADIUS && treeZ < tower.z + tower.depth + BRANCH_RADIUS) {
                             overlaps = true;
                             break;
                         }
                     }
                     if (!overlaps) { validPosition = true; break; }
                 }
                 if (validPosition) {
                     tree.position.set(treeX, 0, treeZ);
                     tree.rotation.y = Math.random() * Math.PI * 2;
                     scene.add(tree);
                     treeMeshes.push(tree);
                 } else {
                     console.warn(`Could not find valid position for tree ${i+1}.`);
                     tree.traverse(child => { if (child.isMesh) { child.geometry.dispose(); } });
                 }
             }
             updateLoadingDetails('Trees generated.');
             console.log(`--- addTrees END (${treeMeshes.length} placed) ---`);
        }

        // --- Core Animation Loop ---
        /** The main render loop, handling camera updates, building growth, rain, and grass. */
        function animate() {
            requestAnimationFrame(animate);
            const delta = Date.now() * 0.0003;

            // Camera Orbit (Isometric Rotating View Only)
            if (currentViewMode === 'iso-rotate' && activeCamera === orthographicCamera) {
                const radius = 100;
                orthographicCamera.position.x = Math.cos(delta) * radius;
                orthographicCamera.position.z = Math.sin(delta) * radius;
                orthographicCamera.position.y = radius * 0.7;
                orthographicCamera.lookAt(0, MAX_HEIGHT * FLOOR_HEIGHT / 6, 0);
                orthographicCamera.updateProjectionMatrix();
            }

            // Building Growth Animation
            if (currentPartIndex < buildingParts.length) {
                const part = buildingParts[currentPartIndex];
                if (part && part.mesh && Math.random() < animationSpeed) {
                    const mesh = part.mesh;
                    mesh.visible = true;
                    const targetScale = part.scale.clone();
                    const targetPosition = part.position.clone();

                    if (mesh.scale.lengthSq() < 0.01) {
                        mesh.scale.set(targetScale.x * 0.01, targetScale.y * 0.01, targetScale.z * 0.01);
                    }
                    mesh.position.copy(targetPosition);
                    if (part.rotation) mesh.rotation.copy(part.rotation);

                    const animateGrowth = (currentMesh, finalScale) => {
                        const growthSpeed = 0.12;
                        currentMesh.scale.lerp(finalScale, growthSpeed);
                        if (currentMesh.scale.distanceTo(finalScale) < 0.005 * finalScale.length()) {
                            currentMesh.scale.copy(finalScale);
                            return true;
                        }
                        return false;
                    };

                    if (mesh.scale.distanceTo(targetScale) > 0.005 * targetScale.length()) {
                        const intervalId = setInterval(() => {
                            if (animateGrowth(mesh, targetScale)) {
                                clearInterval(intervalId);
                                const index = growthIntervals.indexOf(intervalId);
                                if (index > -1) growthIntervals.splice(index, 1);
                            }
                        }, 16);
                        growthIntervals.push(intervalId);
                    } else {
                         mesh.scale.copy(targetScale);
                    }
                    currentPartIndex++;
                } else if (!part || !part.mesh) {
                    currentPartIndex++;
                }
            }

            animateRain();
            animateGrass();

            renderer.render(scene, activeCamera);
        }

        // --- Event Handlers ---
        /** Handles window resize events. */
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            perspectiveCamera.aspect = aspect;
            perspectiveCamera.updateProjectionMatrix();
            const frustumSize = 120;
            orthographicCamera.left = -frustumSize * aspect / 2;
            orthographicCamera.right = frustumSize * aspect / 2;
            orthographicCamera.top = frustumSize / 2;
            orthographicCamera.bottom = -frustumSize / 2;
            orthographicCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /** Resets the building, colors, light, grass, and trees. */
        async function resetBuilding() {
            console.log("--- resetBuilding START ---");
            resetBtn.disabled = true;
            resetBtn.querySelector('.lucide').classList.add('animate-spin');
            updateLoadingDetails('Resetting...');
            growthIntervals.forEach(clearInterval);
            growthIntervals = [];

            await fetchAnalogicComplementPalette();
            randomizeLightDirection();

            if (grassParticles) {
                scene.remove(grassParticles);
                if (grassParticles.geometry) grassParticles.geometry.dispose();
                if (grassParticles.material) grassParticles.material.dispose();
                grassParticles = null; grassOriginalPositions = null;
                console.log("Old grass system removed.");
            }

            updateLoadingDetails('Clearing old trees...');
            console.log("Cleaning up old trees...");
            treeMeshes.forEach(treeGroup => {
                scene.remove(treeGroup);
                treeGroup.traverse(child => { if (child.isMesh) { child.geometry.dispose(); } });
            });
            treeMeshes = [];
            console.log("Old trees removed.");

            generateBuilding();
            initGrass();
            addTrees(TREE_COUNT);

            resetBtn.disabled = false;
            resetBtn.querySelector('.lucide').classList.remove('animate-spin');
            updateLoadingDetails('Ready.');
            console.log("--- resetBuilding END ---");
        }

        /** Saves the current canvas view as a PNG image. */
        function saveImage() {
            try {
                renderer.render(scene, activeCamera); // Ensure latest frame is rendered
                const dataURL = renderer.domElement.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = 'structure_generator_view.png';
                link.href = dataURL;
                link.click();
                console.log("Image saved.");
            } catch (e) {
                console.error("Could not save image:", e);
                alert("Error: Could not save image. See console (F12) for details.");
            }
        }

        /** Sets the active camera and view mode. */
        function setCameraView(mode) {
             console.log(`Setting camera view to: ${mode}`);
             currentViewMode = mode;

             if (mode === 'top') {
                 activeCamera = perspectiveCamera;
                 perspectiveCamera.position.set(0, MAX_HEIGHT * FLOOR_HEIGHT * 2.8, CELL_SIZE * 8);
                 perspectiveCamera.lookAt(0, 0, 0);
                 perspectiveCamera.updateProjectionMatrix();
                 isoIcon.classList.remove('icon-iso-rotate'); // Ensure correct icon state
                 isoIcon.classList.add('icon-iso-still');
                 isoBtn.title = 'Isometric View (Still)';

             } else { // 'iso-still' or 'iso-rotate'
                 activeCamera = orthographicCamera;
                 orthographicCamera.zoom = 1;
                 orthographicCamera.lookAt(0, MAX_HEIGHT * FLOOR_HEIGHT / 6, 0); // Consistent lookAt for iso
                 orthographicCamera.updateProjectionMatrix(); // Apply lookAt

                 if (mode === 'iso-still') {
                      // Position might be set by animate loop if switching from rotate
                      // Update icon/title
                      isoIcon.classList.remove('icon-iso-rotate');
                      isoIcon.classList.add('icon-iso-still');
                      isoBtn.title = 'Isometric View (Still)';
                 } else { // 'iso-rotate'
                      // Update icon/title
                      isoIcon.classList.remove('icon-iso-still');
                      isoIcon.classList.add('icon-iso-rotate');
                      isoBtn.title = 'Isometric View (Rotating)';
                 }
             }
        }

        /** Toggles the isometric view state. */
        function toggleIsoView() {
            if (currentViewMode === 'top') {
                setCameraView('iso-still');
            } else if (currentViewMode === 'iso-still') {
                setCameraView('iso-rotate');
            } else { // currentViewMode === 'iso-rotate'
                setCameraView('iso-still');
            }
        }

        // --- Initialization Function ---
        /** Initializes the entire Three.js scene. */
        async function init() {
            try {
                console.log("--- init START ---");
                updateLoadingDetails('Initializing scene...');
                scene = new THREE.Scene();
                scene.background = new THREE.Color(fogColor);
                scene.fog = new THREE.Fog(fogColor, fogNear, fogFar);

                // Cameras
                const aspect = window.innerWidth / window.innerHeight;
                perspectiveCamera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000 );
                const frustumSize = 120;
                orthographicCamera = new THREE.OrthographicCamera( -frustumSize * aspect / 2, frustumSize * aspect / 2, frustumSize / 2, -frustumSize / 2, 1, 1000 );
                orthographicCamera.position.set(60, 50, 60);
                orthographicCamera.zoom = 1;

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(renderer.domElement);

                // Lighting
                updateLoadingDetails('Setting up lights...');
                const ambientLight = new THREE.AmbientLight(0x708090, 1.2);
                scene.add(ambientLight);
                directionalLight = new THREE.DirectionalLight(0xffffff, 1.1);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 10; directionalLight.shadow.camera.far = 250;
                directionalLight.shadow.camera.left = -120; directionalLight.shadow.camera.right = 120;
                directionalLight.shadow.camera.top = 120; directionalLight.shadow.camera.bottom = -120;
                directionalLight.shadow.bias = -0.002;
                scene.add(directionalLight);
                const hemisphereLight = new THREE.HemisphereLight(0x8090a0, 0x405060, 0.9);
                scene.add(hemisphereLight);

                // Ground Plane
                updateLoadingDetails('Creating ground...');
                const groundGeometry = new THREE.PlaneGeometry(GROUND_PLANE_SIZE, GROUND_PLANE_SIZE);
                const groundMaterial = new THREE.MeshStandardMaterial({ color: UNDERGROUND_COLOR, roughness: 0.95 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.name = "LargeGroundPlane";
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -0.25;
                ground.receiveShadow = true;
                scene.add(ground);

                // --- Setup UI Controls and Event Listeners --- <<< MOVED UP
                // Get references to buttons FIRST
                resetBtn = document.getElementById('resetBtn');
                saveBtn = document.getElementById('saveBtn');
                topBtn = document.getElementById('topBtn');
                isoBtn = document.getElementById('isoBtn');
                isoIcon = document.getElementById('isoIcon'); // Reference to the icon span inside isoBtn

                // Add event listeners
                window.addEventListener('resize', onWindowResize);
                resetBtn.addEventListener('click', async () => { await resetBuilding(); });
                saveBtn.addEventListener('click', saveImage);
                topBtn.addEventListener('click', () => setCameraView('top'));
                isoBtn.addEventListener('click', toggleIsoView);
                // --- End of moved section ---

                // Initialize Rain
                updateLoadingDetails('Making it rain...');
                initRain();

                // Set Initial Camera View (Now safe to call)
                setCameraView('iso-still');

                // Perform Initial Reset
                await resetBuilding();

                // Hide loading, show controls
                document.getElementById('loading').style.display = 'none';
                document.querySelector('.controls').style.display = 'flex';

                // Start Animation
                animate();
                console.log("--- init END --- Scene Initialized Successfully");

            } catch (error) {
                // Error Handling
                console.error("Error initializing scene:", error);
                const loadingDiv = document.getElementById('loading');
                if(loadingDiv) {
                    // Display the specific error message
                    loadingDiv.innerHTML = `Initialization Error: ${error.message}.<br>Check console (F12) for details.`;
                    loadingDiv.style.color = '#fecaca'; /* Tailwind red-200 */
                    loadingDiv.style.background = 'rgba(153, 27, 27, 0.8)'; /* Tailwind red-800 */
                    loadingDiv.style.display = 'block';
                }
                const controlsDiv = document.querySelector('.controls');
                if (controlsDiv) controlsDiv.style.display = 'none';
            }
        } // End init()

    </script>
</body>
</html>
